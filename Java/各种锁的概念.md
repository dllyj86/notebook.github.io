## 递归锁
同一个线程可以重复获取同一把锁而不会被阻塞

## Java的Synchronized 和 ReentrantLock 

| **特性**     | **`synchronized`** | **`ReentrantLock`**                                         |
| ---------- | ------------------ | ----------------------------------------------------------- |
| **实现机制**   | JVM 内置关键字，由 JVM 实现 | Java 类（`java.util.concurrent.locks.ReentrantLock`）提供，基于代码实现 |
| **可重入性**   | 是                  | 是                                                           |
| **公平性**    | 非公平锁（默认，无法设置）      | 支持公平锁和非公平锁，通过构造函数指定（`ReentrantLock(true)` 为公平锁）             |
| **锁的释放**   | 自动释放（锁块执行完毕后自动释放）  | 必须手动释放（调用 `unlock` 方法）                                      |
| **锁的尝试**   | 不支持                | 支持尝试加锁（`tryLock()`），可以设置超时时间避免线程阻塞                          |
| **中断响应**   | 不支持                | 支持线程中断（如调用 `lockInterruptibly()`）                           |
| **条件变量支持** | 不支持                | 支持多个条件变量（`Condition`），可实现更灵活的等待/通知机制                        |
| **性能**     | 在低争用场景性能较好         | 在高并发场景下性能更优                                                 |
| **适用场景**   | 简单同步场景             | 复杂同步场景，或需要更灵活的锁控制                                           |

ReentrantLock的用法的例子:
```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void methodA() {
        lock.lock();
        try {
            System.out.println("Method A");
            methodB();
        } finally {
            lock.unlock();
        }
    }

    public void methodB() {
        lock.lock();
        try {
            System.out.println("Method B");
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        ReentrantLockExample example = new ReentrantLockExample();
        example.methodA();
    }
}
```

## 可重入性
同一线程可以重复获取锁, 每获取一次计数加1. 每释放一次, 计数减1.

## 自旋锁
线程在获取锁的时候, 如果锁被占用, 线程不会进入休眠状态, 而是持续尝试获取锁. 这个叫自旋等待.

## 红锁
Redis的锁. 用于提高分布式锁的可靠性. 
获取锁的机制:
1. 客户端提供唯一的UUID
2. 假如有5个Redis节点, 每个节点都会使用 `SET key value NX PX` (仅在不存在时才设置值, 并且带超时机制) 加锁. 当加锁达到3个 (多数节点) 了, 才算加锁成功.  设置的key就是UUID. 
3. 删除锁时也要根据UUID删除锁
优点:
高可靠性, 高可用
要注意的点:
锁要设置超时时间. 要提供唯一的标识, 确保可以释放. 确保锁的获取和释放都在合理的时间内完成. 

## 公平锁 和 非公平锁

| 特性                         | 公平锁        | 非公平锁                |
| -------------------------- | ---------- | ------------------- |
| 获取锁的顺序                     | 按照请求的先后顺序  | 可能打破顺序，后来的线程可能优先获取锁 |
| 性能                         | 较低（维护队列开销） | 较高                  |
| 是否可能出现饥饿现象 (某些线程可能长期无法获得锁) | 否          | 是                   |
| 场景适用                       | 要求严格公平性时   | 追求高吞吐量时             |
## 共享锁和独占锁
共享锁, 多个线程可以一起访问, 比如ReentrantReadWriteLock
独占锁, 只有一个线程可以访问, 比如ReentrantLock和写锁

## 读写锁 ReentrantReadWriteLock
读写锁提供了读写分离的机制. 位于 `java.util.concurrent.locks` 包. 
多个线程可以同时获得读锁
写锁是独占的. 写线程需要等所有读线程释放锁.
读锁和写锁互斥.

读取加锁是为了防止线程读取到正在被线程写入的数据, 导致读取的数据不完整或者不准确. 所以**读锁是为了不让写, 而不是要限制读**.

读写锁的应用场景是那些读大于写的应用: 缓存系统, 配置中心系统, 

## 乐观锁和悲观锁

| 特性          | 悲观锁                                                                               | 乐观锁                                                                                 |
| ----------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **实现方式**    | 通过数据的锁 (行, 表锁)或Java的同步机制(synchronized, ReentrantLock) 实现<br><br>锁会阻塞其他线程的操作, 直到释放 | 通过版本号或时间戳判断.<br><br>读取前, 读取数据的版本号, 更新操作时检查版本号. 没变化, 说明没人修改, 更新成功. 有变化, 说明有冲突, 重试或放弃 |
| **并发模型**    | 加锁，阻止其他操作                                                                         | 不加锁，检测冲突后重试或者放弃                                                                     |
| **性能**      | 高冲突场景下性能较优                                                                        | 低冲突场景下性能较优                                                                          |
| **开销**      | 需要锁的管理和上下文切换                                                                      | 需要重试机制                                                                              |
| **适用场景**    | 数据争用严重，高冲突的操作<br><br>减库存, 银行转账                                                    | 数据争用较少，读多写少的操作<br><br>缓存, 配置中心                                                      |
| **Java 实现** | `synchronized`，`ReentrantLock`                                                    | `AtomicInteger`，`CAS`                                                               |

# MySQL领域的锁

## 手动加锁的情况
普通的CRUD操作, mysql就可以自己控制锁了, 不需要手动添加锁的语句.
当编写了事务 (transaction) 的时候, 如果事务里面涉及到多个操作步骤, 并且需要保证数据的一致性, 就需要手动协商加锁的语句. 比如:
1. 防止这个事务发生并发调用, 修改同样的数据.
2. 确保查询结果在多次操作期间保持不变 (避免幻读)
3. 跨多个表操作需要保持一致性

保证事务提交前, 其他事务无法修改id=123的记录:
```sql
START TRANSACTION;
SELECT stock FROM products WHERE id = 123 FOR UPDATE;
-- 根据查询结果进行操作
UPDATE products SET stock = stock - 1 WHERE id = 123;
COMMIT;
```
防止其他事务插入新数据导致幻读:
```sql
START TRANSACTION;
SELECT * FROM orders WHERE user_id = 1 FOR UPDATE;
-- 确保查询结果在后续操作中不会发生变化
INSERT INTO orders (user_id, product_id) VALUES (1, 456);
COMMIT;

```
## 表级锁
锁住整个表
## 行级锁
锁住一整行记录

## 间隙锁
间隙锁是在查询语句查询一个范围的记录时, 将这个查询范围之内的记录锁定. 可以理解成它锁定了两个索引之间的间隙. 防止查询时, 其他事务在间隙中插入新记录, 导致幻读. 

间隙是指两个索引之间, 比如表中存在1, 10, 20 三条记录, 那么间隙包括：`(-∞, 1)`、`(1, 10)`、`(10, 20)`、`(20, +∞)`。

间隙锁只会在基于`索引`的操作中生效, 比如插入数据会修改表的索引. 因此修改这个范围内的已有的记录不受间隙锁影响.

**间隙锁的触发条件**
- 使用范围查询语句, 比如 `<`, `>`, `<=`, `>=`, `between`, `like`
- 在事务中使用了`select ... for update`或者`select ... lock in share mode`等加锁的语句.
- 适用于`REPEATABLE READ`隔离级别

**间隙锁不会触发的场景**
- 精确查找时 (不会使用范围查询) , 不会触发. 只会对精确的行加行锁
- 查询没有使用索引, 会退化成表锁 
- 隔离级别时Read commited, 不需要处理幻读, 所以不会触发.
- 仅插入操作, 而且查询语句不涉及到范围查询
- 唯一索引插入冲突的值(索引值重复) , InnoDB引擎会锁住行, 以解决冲突. 防止重复插入.

例子:
```sql
START TRANSACTION;
SELECT * FROM orders WHERE amount > 100 FOR UPDATE;
-- 锁定所有满足条件的记录以及它们之间的间隙
```
其他事务试图插入满足条件（`amount > 100`）的新记录时，将被阻塞。
如果orders表没有创建索引(注意, 是索引, 不是主键), 会退化成表锁

**常见的问题**
- 只在索引上生效. 如果查询语句中没有使用索引, 就会退化成表锁, 锁住整个表
- 导致并发性能下降
- 可能导致死锁, 因为会锁住一个范围, 可能导致多个事务互相等待
## 临键锁
临建锁是在间隙锁的基础上, 将匹配到的记录也加上行锁. 也是为了解决幻读的问题. 

**触发条件**
- 适用范围查询, 比如 `<`, `>`, `<=`, `>=`, `between`, `like`
- 在事务中手动加锁, 使用 `SELECT ... FOR UPDATE` 或 `SELECT ... LOCK IN SHARE MODE`
- 在repeatable read隔离级别下. MySQL 默认隔离级别为 `REPEATABLE READ`，此时会启用临键锁机制

**间隙锁不会触发的场景**
- 精确查找时 (不会使用范围查询) , 不会触发. 只会对精确的行加行锁
- 查询没有使用索引, 会退化成表锁 
- 隔离级别时Read commited, 不需要处理幻读, 所以不会触发.
- 仅插入操作, 而且查询语句不涉及到范围查询
- 唯一索引插入冲突的值(索引值重复) , InnoDB引擎会锁住行, 以解决冲突. 防止重复插入.

**常见的问题**
- 只在索引上生效. 如果查询没有索引, 则退化成表锁
- 可能导致并发性能下降
- 可能导致死锁. 

## 意向锁
意向锁是表级锁. 标识事务**打算**给表中的某些行加锁. 主要用来提高检查锁的效率. 优化锁之间的冲突.
意向共享锁, 表示打算对某些行加共享锁
意向排他锁, 表示打算对某些行加排他锁
## 共享锁
主要用于并发读. 允许多个事务同时读同一行数据. 但是禁止任何事务修改这一行.
## 排他锁
主要用户增, 删, 改. 只允许一个事务锁住一行数据, 禁止其他事务读或者写这一行.
## 外键锁
外键锁确保事务执行过程中, 父表(主键的表) 和 子表(有外键的表) 的数据不会违反外键约束. 通过加锁, 防止其他事务在当前事务完成前破坏数据完整性. 

外键锁是行级锁

删除父表的记录, 会给子表记录加锁, 防止子表中还存在对父级表记录的引用
插入子表记录, 会给父表记录加锁, 确保外键引用的父级表的记录存在.
父表级联操作时 (on delete cascade 或 ON UPDATE CASCADE), 会给子表进行级联删除或更新, 给子表记录加锁. 

特殊情况会是表级锁, 比如删除整张父表时, 给子表整个加锁.

## 元数据锁
MySQL自动执行. 保护元数据.
场景: 当DDL操作(alter table) 和DML操作 (insert) 发生冲突时用
## 全局锁
锁住整个数据库实例

# 一些与锁相关的用法
## 双重检查锁定
单例模式的懒汉式, 使用双重检查锁定的方式保证线程安全
```java
// 懒汉式
public class Singleton {
// 延迟加载保证多线程安全
    Private volatile static Singleton singleton;
    private Singleton(){}
    public static Singleton getInstance(){
        if(singleton == null){
            synchronized(Singleton.class){
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

- 使用 volatile 是**防止指令重排序，保证对象可见**，防止读到半初始化状态的对象
- 第一层if(singleton == null) 是为了防止有多个线程同时创建
- synchronized 是加锁防止多个线程同时进入该方法创建对象
- 第二层if(singleton == null) 是防止有多个线程同时等待锁，一个执行完了后面一个又继续执行的情况

### 防止指令重排, 保证对象可见性的含义
这句话指的是 `volatile` 关键字在 Java 中的两个主要作用：**防止指令重排序** 和 **保证对象可见性**。

#### 1. **保证对象可见性**

- **可见性**是指当一个线程修改了共享变量的值，其他线程能立即看到这个修改的值。
    
- 在多线程环境中，如果一个线程修改了共享变量的值，其他线程可能无法立即看到这个修改的值，尤其是当共享变量存储在不同的 CPU 缓存中时。每个线程有自己的局部缓存，这可能导致多个线程访问同一变量时，不同步或者看到的是过时的值。
    
    **`volatile` 关键字**可以确保变量在所有线程之间的可见性。当一个变量被声明为 `volatile` 时，它会强制线程从主内存中读取该变量的最新值，而不是使用线程本地缓存。这样，无论哪个线程更新了该变量，其他线程都能立即看到更新后的值。
    
    **例子：**
    
    ```java
    class SharedResource {
        private volatile boolean flag = false;
    
        public void setFlag() {
            flag = true;  // 线程1设置 flag 为 true
        }
    
        public boolean getFlag() {
            return flag;  // 线程2读取 flag
        }
    }
    ```
    
    在这个例子中，`flag` 变量被声明为 `volatile`，这样当线程1更新 `flag` 的值时，线程2能够立刻看到 `flag` 的更新。
    

---

#### 2. **防止指令重排序**

- **指令重排序**是指编译器和处理器出于性能优化的目的，在执行程序时可能会调整指令的顺序。虽然这种调整不会改变单个线程中的执行顺序，但它可能会导致不同线程间的可见性问题。
    
    在多线程环境中，指令重排序可能导致线程之间的执行顺序出现问题。例如，线程1可能会先执行某些计算操作，而后执行变量更新操作；线程2可能会看到这些计算结果，但并没有看到变量更新操作的结果，导致不一致的行为。
    
    **`volatile` 关键字**通过禁止指令重排序来保证操作的顺序性，特别是在对 `volatile` 变量进行读取和写入时，JVM 会插入适当的内存屏障（memory barrier）来防止重排序，确保程序执行的顺序按照程序代码的顺序进行。
    
    **例子：**
    
    ```java
    class SharedResource {
        private volatile boolean flag = false;
        private int value = 0;
    
        public void method1() {
            value = 42;
            flag = true;  // 在 method1 中，flag 的更新保证是可见的
        }
    
        public void method2() {
            if (flag) {
                // 如果 flag 被设置为 true，则可以安全地使用 value
                System.out.println(value);  // 读取 value
            }
        }
    }
    ```
    
    在这个例子中，`volatile` 保证了 `flag` 变量的写操作不会被重排序到 `value = 42` 之前。也就是说，线程2（调用 `method2`）一定会看到线程1（调用 `method1`）中 `flag` 的更新，并且可以安全地使用 `value`。
    

---

#### 3. **总结：**

- **`volatile` 的可见性**：保证线程对 `volatile` 变量的写操作对其他线程立刻可见。
- **`volatile` 的指令重排序**：通过插入内存屏障，确保对 `volatile` 变量的读写操作不会被重排序，从而保持程序的正确执行顺序。

`volatile` 的关键作用是保证多线程环境中对共享变量的正确可见性和顺序性，但它并不能完全代替锁。在需要多个线程操作同一个变量时，若要保证**原子性**操作，仍然需要使用 `synchronized` 或其他并发工具。